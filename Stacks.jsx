/*	1.0		Release	1.01 	Fixed mask bug when scaling fractions	1.02	Fixed mask bug that clipped path strokes. Changed from bounds to strokeBounds.	2.0      Rewrote the script in jsx for the newer versions of Illustrator.*/var sversion = '2.0',	scriptName = 'dViz: Stacks' + ' ' + sversion;var doc;var val = 1,    r = 1,    c = 1,    v_gutter = 0,    h_gutter = 0,    fraction_style = 0,    draw_mode = 0,    styleList = ['Scale', 'Top/Down', 'Bottom/Up', 'Left/Right', 'Round Up', 'Round Down'],    drawList = ['Rows', 'Columns'];if (version.split(".")[0] >= 15) {    if (app.documents.length > 0) {        if (app.activeDocument != null) {            doc = app.activeDocument;            var dlg = new Window('dialog', scriptName);                         dlg.valueInputGroup = dlg.add('group', undefined, 'Value input fields');            (dlg.valueInputGroup.valueInput = dlg.valueInputGroup.add('edittext', [100,15,160,35], val));            (dlg.valueInputGroup.percent = dlg.valueInputGroup.add('statictext', undefined, '%'));            dlg.valueInputGroup.valueInput.onChange = function() {                val = parseFloat(dlg.valueInputGroup.valueInput.text.replace(/[^\d.-]/g, ''));                if (val > 100) {                    val = 100;                    dlg.valueInputGroup.valueInput.text= val;                }            }            dlg.valueInputGroup.orientation = 'row';                        dlg.rowcolInputGroup = dlg.add('group', undefined, 'Rows and columns');            (dlg.rowcolInputGroup.rInput = dlg.rowcolInputGroup.add('edittext', [100,15,160,35], r));            (dlg.rowcolInputGroup.percent = dlg.rowcolInputGroup.add('statictext', undefined, 'Rows'));            (dlg.rowcolInputGroup.cInput = dlg.rowcolInputGroup.add('edittext', [100,15,160,35], c));            (dlg.rowcolInputGroup.percent = dlg.rowcolInputGroup.add('statictext', undefined, 'Columns'));            dlg.rowcolInputGroup.orientation = 'row';                        dlg.guttersInputGroup = dlg.add('group', undefined, 'Gutters');            (dlg.guttersInputGroup.vInput = dlg.guttersInputGroup.add('edittext', [100,15,160,35], v_gutter));            (dlg.guttersInputGroup.percent = dlg.guttersInputGroup.add('statictext', undefined, 'Vertical Gutter'));            (dlg.guttersInputGroup.hInput = dlg.guttersInputGroup.add('edittext', [100,15,160,35], h_gutter));            (dlg.guttersInputGroup.percent = dlg.guttersInputGroup.add('statictext', undefined, 'Horizontal Gutter'));            dlg.guttersInputGroup.orientation = 'row';                        dlg.styleInputGroup = dlg.add('group', undefined, 'Fraction style');            (dlg.styleInputGroup.percent = dlg.styleInputGroup.add('statictext', undefined, 'Fraction style:'));            (dlg.styleInputGroup.styleList = dlg.styleInputGroup.add('dropdownlist', undefined, styleList));            dlg.styleInputGroup.styleList.selection = 0;            dlg.styleInputGroup.orientation = 'row';                        dlg.drawInputGroup = dlg.add('group', undefined, 'Draw mode');            (dlg.drawInputGroup.percent = dlg.drawInputGroup.add('statictext', undefined, 'Draw mode:'));            (dlg.drawInputGroup.drawList = dlg.drawInputGroup.add('dropdownlist', undefined, drawList));            dlg.drawInputGroup.drawList.selection = 0;            dlg.drawInputGroup.orientation = 'row';                        dlg.buttonGroup = dlg.add('group', undefined, 'Button Group');            dlg.buttonGroup.cancelBtn = dlg.buttonGroup.add('button', undefined, 'Cancel', {name:'cancel'});            dlg.buttonGroup.cancelBtn.onClick = function() {dlg.close();};            dlg.buttonGroup.okBtn = dlg.buttonGroup.add('button', undefined, 'OK', {name:'ok'});            dlg.buttonGroup.okBtn.onClick = function() {                var selectedObjects = doc.selection;                                if (selectedObjects.length != 0) {                    storeValues();                                        Window.alert(val + ' ' + r  + ' ' + c + ' ' + v_gutter + ' ' + h_gutter);                    if (val != 0) {                        selectedObjects.clone();                    } else { Window.alert("The value must be different to 0."); }                    dlg.close();                } else { Window.alert("The selection is empty."); }            }            dlg.buttonGroup.orientation = 'row';            dlg.show();        } else { Window.alert("You must have an active document to run this script."); }    } else { Window.alert("You must open at least one document to run this script."); }} else { Window.alert("Your version of Adobe illustrator is too old to run this script."); }function storeValues() {    val = parseFloat(dlg.valueInputGroup.valueInput.text.replace(/[^\d.-]/g, ''));    r = parseInt(dlg.rowcolInputGroup.rInput.text.replace(/[^\d.-]/g, ''));    c = parseInt(dlg.rowcolInputGroup.cInput.text.replace(/[^\d.-]/g, ''));    v_gutter = parseInt(dlg.guttersInputGroup.vInput.text.replace(/[^\d.-]/g, ''));    h_gutter = parseInt(dlg.guttersInputGroup.hInput.text.replace(/[^\d.-]/g, ''));    //draw_fractions = 'Bottom/Up';}var comps = {	MONOVEKTOR:{		type: 'text',		value: 'by MONOVEKTOR 2012'		},	NUM:{		type: 'number',		label: 'Amount',		min: 0,		onChange: function(value){			comps.C.max = value			comps.R.max = value			comps.C.value = Math.ceil(Math.sqrt(value))			comps.R.value = Math.round(Math.sqrt(value))		}		},	C:{		type: 'number',		label: 'Columns',		steppers: true,		increment: 1,		min: 1,		max: 1,		onChange: function(value){			comps.R.value = Math.ceil(comps.NUM.value / value)		}		},	R:{		type: 'number',		label: 'Rows',		steppers: true,		increment: 1,		min: 1,		max: 1,		onChange: function(value){			comps.C.value = Math.ceil(comps.NUM.value / value)		}		},	RULER_01:{		type: 'ruler',		},	V_GUTTER:{		type: 'number',		label: 'V Gutter',		units: 'point',		steppers: true,		},	H_GUTTER:{		type: 'number',		label: 'H Gutter',		units: 'point',		steppers: true,		},	DRAW_FRACTIONS:{		type: 'list',		label: 'Display\nFractions',		options: ['Scale', 'Top/Down', 'Bottom/Up', 'Left/Right', 'Round Up', 'Round Down']		},	DRAW_ORDER:{		type: 'list',		label: 'Draw',		options: ['Rows', 'Columns']		},	RULER_02:{		type: 'ruler'		},	DO_IT:{		type: 'button',		label: 'Make',		onClick: function(){			var selectedItems = document.getItems({selected: true}),				theAmount = comps.NUM.value			if(theAmount > 0 && selectedItems){				if(comps.DRAW_FRACTIONS.value == 'Round Up') theAmount = Math.ceil(theAmount)				if(comps.DRAW_FRACTIONS.value == 'Round Down') theAmount = Math.floor(theAmount)				var item = selectedItems[0],					bounds = item.strokeBounds,					gutterSize = new Size(comps.V_GUTTER.value, comps.H_GUTTER.value),					x = 0,					y = 0,					stackLength = Math.ceil(theAmount),					fraction = theAmount % 1,					group = new Group()				group.name = 'Stack'				item.selected = false				// Stack Routine				while(stackLength > 0){					// Copy the selected item					var itemCopy = item.clone()					// Position it					itemCopy.position = new Point(x, y) * (bounds.size + gutterSize)					itemCopy.name = '# ' + (stackLength -1)					if(comps.DRAW_ORDER.value == 'Rows'){						// Draw the rows...						x++						if(x == comps.C.value){							y++							x = 0						}					} else {						//...or the columns						y++						if(y == comps.R.value){							x++							y = 0						}					}					stackLength--					group.appendTop(itemCopy)				}				// Special treatment for fractions				if(fraction){					var maskSize = new Size(),						fractionGroup = new Group()					fractionGroup.name = 'Fraction ' + fraction.toFixed(3)					// Different kinds of ways to display fractions					if(comps.DRAW_FRACTIONS.value == 'Scale'){						itemCopy.scale(fraction)					} else {						if(comps.DRAW_FRACTIONS.value == 'Top/Down'){							maskSize.width = bounds.width							maskSize.height = bounds.height * fraction						} else if(comps.DRAW_FRACTIONS.value == 'Bottom/Up'){							maskSize.width = bounds.width							maskSize.height = -bounds.height * fraction						} else if(comps.DRAW_FRACTIONS.value == 'Left/Right'){							maskSize.width = bounds.width * fraction							maskSize.height = bounds.height						}						// Make a rectangular mask						var mask = new Path.Rectangle(comps.DRAW_FRACTIONS.value == 'Bottom/Up' ? itemCopy.strokeBounds.bottomLeft : itemCopy.strokeBounds.topLeft, maskSize)						fractionGroup.appendTop(mask)						fractionGroup.clipped = true					}					fractionGroup.appendBottom(itemCopy)					group.appendTop(fractionGroup)				}			} else {				return false			}		}		}}